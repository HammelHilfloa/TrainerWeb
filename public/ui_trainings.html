<section id="view-trainings" class="active">
  <div class="filters" aria-label="Trainings filtern">
    <label class="chip-toggle">
      <input type="checkbox" id="filterNeed" />
      <span>Nur Trainings mit Bedarf</span>
    </label>
    <label class="switch">
      <input type="checkbox" id="togglePast" />
      <span>Vergangene anzeigen</span>
    </label>
    <div class="filter-row">
      <label class="select-label">
        <span>Gruppe</span>
        <select id="filterGroup">
          <option value="">Alle Gruppen</option>
        </select>
      </label>
      <label class="select-label">
        <span>Monat</span>
        <select id="monthFilter">
          <option value="">Alle Monate</option>
        </select>
      </label>
    </div>
  </div>

  <div id="trainingsList" class="training-list" aria-live="polite"></div>
</section>

<script>
  const TrainingsView = (() => {
    const filters = {
      needOnly: false,
      group: '',
      month: '',
    };

    const state = {
      upcoming: [],
      allTrainings: [],
      mineActive: [],
      myUnavailable: [],
      enrolledByTrainingId: new Map(),
      unavailableSet: new Set(),
    };

    const STORAGE_SHOW_PAST = 'vh_showPast';
    let showPast = false;

    const els = {
      list: null,
      filterNeed: null,
      filterGroup: null,
      filterMonth: null,
      togglePast: null,
    };

    function initElements() {
      els.list = document.querySelector('#trainingsList');
      els.filterNeed = document.querySelector('#filterNeed');
      els.filterGroup = document.querySelector('#filterGroup');
      els.filterMonth = document.querySelector('#monthFilter');
      els.togglePast = document.querySelector('#togglePast');
    }

    function renderEmpty(message) {
      if (!els.list) return;
      els.list.innerHTML = `<p class="empty-hint">${message}</p>`;
    }

    function getActiveList() {
      const base = showPast ? state.allTrainings : state.upcoming;
      return Array.isArray(base) ? base : [];
    }

    function applyFilters() {
      return getActiveList()
        .filter((tr) => {
          if (filters.needOnly && tr.offen <= 0) return false;
          if (filters.group && tr.gruppe !== filters.group) return false;
          if (filters.month && tr.monthKey !== filters.month) return false;
          return true;
        })
        .sort((a, b) => a.datumTs - b.datumTs);
    }

    function renderList() {
      if (!els.list) return;
      const items = applyFilters();
      if (!items.length) {
        renderEmpty('Keine Trainings gefunden.');
        return;
      }

      const frag = document.createDocumentFragment();
      items.forEach((tr) => {
        const card = document.createElement('article');
        card.className = 'training-card card';
        if (tr.offen > 0) card.classList.add('needs-attention');
        card.innerHTML = `
          <div class="training-top">
            <div>
              <p class="muted">${tr.datum} · ${tr.start}&ndash;${tr.ende}</p>
              <h3 class="training-title">${tr.gruppe}</h3>
              <p class="muted">${tr.ort || ''}</p>
            </div>
            <div class="badge-stack">
              ${UIComponents.badge(tr.status || 'Status', 'info')}
              ${tr.is_unavailable ? UIComponents.badge('Nicht verfügbar', 'danger') : ''}
            </div>
          </div>
          <div class="training-meta">
            <span>${UIComponents.emphasis(`Eingeteilt ${tr.eingeteilt}`)} / benötigt ${tr.benoetigt_trainer}</span>
            <span class="highlight">${tr.offen_text}</span>
          </div>
        `;
        card.addEventListener('click', () => openDetails(tr));
        card.appendChild(createTrainingActions(tr));
        frag.appendChild(card);
      });

      els.list.innerHTML = '';
      els.list.appendChild(frag);
    }

    function populateGroups() {
      if (!els.filterGroup) return;
      const values = Array.from(new Set(getActiveList().map((u) => u.gruppe).filter(Boolean))).sort((a, b) =>
        a.localeCompare(b, 'de'),
      );
      els.filterGroup.innerHTML = '<option value="">Alle Gruppen</option>';
      values.forEach((g) => {
        const opt = document.createElement('option');
        opt.value = g;
        opt.textContent = g;
        els.filterGroup.appendChild(opt);
      });
      if (filters.group && !values.includes(filters.group)) {
        filters.group = '';
      }
    }

    function computeMonthKey(training) {
      const ts = Number(training?.datumTs);
      if (!Number.isNaN(ts) && ts > 0) {
        const d = new Date(ts);
        if (!Number.isNaN(d.getTime())) {
          return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
        }
      }

      const parts = String(training?.datum || '').split('.');
      if (parts.length === 3) {
        const [, month, year] = parts;
        if (month && year) return `${year}-${String(month).padStart(2, '0')}`;
      }
      return '';
    }

    function formatMonthLabel(key) {
      if (!key) return '';
      const [year, month] = key.split('-');
      const monthIdx = Number(month) - 1;
      const names = [
        'Januar',
        'Februar',
        'März',
        'April',
        'Mai',
        'Juni',
        'Juli',
        'August',
        'September',
        'Oktober',
        'November',
        'Dezember',
      ];
      const name = names[monthIdx] || month;
      return `${name} ${year}`;
    }

    function populateMonths() {
      if (!els.filterMonth) return;
      const monthKeys = Array.from(new Set(getActiveList().map((u) => u.monthKey).filter(Boolean))).sort();
      const now = new Date();
      const currentMonthKey = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;

      let nextValue = filters.month;
      if (!monthKeys.includes(nextValue)) {
        nextValue = monthKeys.includes(currentMonthKey) ? currentMonthKey : '';
      }

      els.filterMonth.innerHTML = '<option value="">Alle Monate</option>';
      monthKeys.forEach((key) => {
        const opt = document.createElement('option');
        opt.value = key;
        opt.textContent = formatMonthLabel(key);
        els.filterMonth.appendChild(opt);
      });

      filters.month = nextValue;
      els.filterMonth.value = nextValue;
    }

    function buildEnrolledByTrainingId() {
      const map = new Map();
      state.mineActive.forEach((entry) => {
        if (!entry.ausgetragen) {
          map.set(String(entry.training_id), String(entry.einteilung_id));
        }
      });
      state.enrolledByTrainingId = map;
    }

    function buildUnavailableSet() {
      const set = new Set();
      [...state.upcoming, ...state.allTrainings].forEach((tr) => {
        if (tr?.training_id && tr.is_unavailable) set.add(String(tr.training_id));
      });
      state.myUnavailable.forEach((unavailable) => {
        if (unavailable?.training_id) set.add(String(unavailable.training_id));
      });
      state.unavailableSet = set;
    }

    function refreshFiltersForData() {
      populateGroups();
      populateMonths();
    }

    function setData(bootstrap) {
      state.myUnavailable = Array.isArray(bootstrap?.myUnavailable) ? bootstrap.myUnavailable : [];

      const unavailableIds = new Set(
        state.myUnavailable.map((u) => String(u.training_id)).filter(Boolean),
      );

      const normalizeTraining = (tr) => {
        const trainingId = String(tr.training_id);
        const isUnavailable = tr.is_unavailable || unavailableIds.has(trainingId);
        return { ...tr, monthKey: computeMonthKey(tr), is_unavailable: !!isUnavailable };
      };

      state.upcoming = Array.isArray(bootstrap?.upcoming)
        ? bootstrap.upcoming.map(normalizeTraining)
        : [];
      state.allTrainings = Array.isArray(bootstrap?.allTrainings)
        ? bootstrap.allTrainings.map(normalizeTraining)
        : [];
      state.mineActive = Array.isArray(bootstrap?.mineActive) ? bootstrap.mineActive : [];

      buildEnrolledByTrainingId();
      buildUnavailableSet();
      refreshFiltersForData();
      renderList();
    }

    function registerFilterEvents() {
      if (els.filterNeed) {
        els.filterNeed.addEventListener('change', (ev) => {
          filters.needOnly = !!ev.target.checked;
          renderList();
        });
      }
      if (els.filterGroup) {
        els.filterGroup.addEventListener('change', (ev) => {
          filters.group = ev.target.value;
          renderList();
        });
      }
      if (els.filterMonth) {
        els.filterMonth.addEventListener('change', (ev) => {
          filters.month = ev.target.value;
          renderList();
        });
      }
      if (els.togglePast) {
        els.togglePast.addEventListener('change', (ev) => {
          showPast = !!ev.target.checked;
          try {
            localStorage.setItem(STORAGE_SHOW_PAST, showPast ? '1' : '0');
          } catch (e) {}
          refreshFiltersForData();
          renderList();
        });
      }
    }

    function findOwnEinteilung(trainingId) {
      return state.mineActive.find((e) => String(e.training_id) === String(trainingId) && !e.ausgetragen);
    }

    function renderTrainerList(title, list, emptyText) {
      const items = list
        .map((t) => `<li><span class="name">${t.name}</span>${t.rolle ? `<span class="muted">${t.rolle}</span>` : ''}</li>`)
        .join('');
      return `
        <div class="section">
          <div class="section-title">${title}</div>
          ${list.length ? `<ul class="list">${items}</ul>` : `<p class="muted small">${emptyText}</p>`}
        </div>
      `;
    }

    function renderUnavailable(list) {
      const items = list
        .map((t) => `<li><span class="name">${t.name}</span>${t.grund ? `<span class="muted">${t.grund}</span>` : ''}</li>`)
        .join('');
      return `
        <div class="section">
          <div class="section-title">Nicht verfügbar</div>
          ${list.length ? `<ul class="list">${items}</ul>` : '<p class="muted small">Keine Abmeldungen.</p>'}
        </div>
      `;
    }

    function renderPlan(plan) {
      const hasPlan = !!plan;
      const content = hasPlan
        ? `
          <div class="plan-box">
            <p class="plan-title">${plan.titel || 'Plan'}</p>
            <p class="muted">${plan.inhalt || 'Kein Inhalt hinterlegt.'}</p>
            ${plan.link ? `<a class="btn ghost" href="${plan.link}" target="_blank" rel="noopener">Zum Plan</a>` : ''}
          </div>
        `
        : '<p class="muted small">Noch kein Plan</p>';

      return `
        <div class="section">
          <div class="section-title">Trainingsplan</div>
          ${content}
        </div>
      `;
    }

    function setButtonLoading(btn, loading) {
      if (!btn) return;
      btn.disabled = !!loading;
      if (loading) {
        btn.dataset.prevText = btn.textContent;
        btn.textContent = 'Bitte warten...';
      } else if (btn.dataset.prevText) {
        btn.textContent = btn.dataset.prevText;
        delete btn.dataset.prevText;
      }
    }

    function isTrainingPast(training) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const ts = Number(training?.datumTs);
      if (!Number.isNaN(ts) && ts > 0) {
        return ts < today.getTime();
      }
      const parts = String(training?.datum || '').split('.');
      if (parts.length === 3) {
        const [day, month, year] = parts;
        const parsed = new Date(Number(year), Number(month) - 1, Number(day));
        if (!Number.isNaN(parsed.getTime())) {
          return parsed.getTime() < today.getTime();
        }
      }
      return false;
    }

    function createTrainingActions(training) {
      const actionRow = document.createElement('div');
      actionRow.className = 'training-actions';

      const right = document.createElement('div');
      right.className = 'training-actions-right';

      const trainingId = String(training.training_id);
      const isPlanned = String(training.status) === 'geplant';
      const isUnavailable = state.unavailableSet.has(trainingId);
      const entryId = state.enrolledByTrainingId.get(trainingId);
      const isPast = isTrainingPast(training);

      const createBtn = (label, variant, onClick, disabled = false) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = `btn ${variant}`;
        btn.textContent = label;
        btn.disabled = disabled;
        btn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          ev.preventDefault();
          if (typeof onClick === 'function' && !btn.disabled) {
            onClick(btn);
          }
        });
        right.appendChild(btn);
        return btn;
      };

      if (isUnavailable) {
        createBtn('Verfügbar', 'primary', (btn) => handleUnavailable(training, false, btn), false);
      } else if (entryId) {
        createBtn('Austragen', 'ghost', (btn) => handleWithdraw(training, { button: btn, entryId }), !isPlanned || isPast);
      } else {
        createBtn('Eintragen', 'primary', (btn) => handleEnroll(training, { button: btn }), !isPlanned || isPast);
      }

      actionRow.appendChild(right);
      return actionRow;
    }

    async function handleEnroll(training, opts = {}) {
      const { button = null, reopenDetails = false } = opts;
      setButtonLoading(button, true);
      const res = await apiAuthed('apiEnroll', training.training_id);
      setButtonLoading(button, false);
      if (!res || !res.ok) {
        showToast(res && res.error ? res.error : 'Konnte nicht eintragen', 'error');
        return;
      }
      showToast('Du wurdest eingetragen');
      showSpinner(true);
      await refreshBootstrap(true);
      showSpinner(false);
      if (reopenDetails) {
        await openDetails(training, true);
      }
    }

    async function handleWithdraw(training, opts = {}) {
      const { button = null, entryId = null, reopenDetails = false } = opts;
      const effectiveEntryId = entryId || state.enrolledByTrainingId.get(String(training.training_id));
      if (!effectiveEntryId) {
        showToast('Kein eigener Eintrag gefunden', 'error');
        return;
      }
      setButtonLoading(button, true);
      const res = await apiAuthed('apiWithdraw', effectiveEntryId);
      setButtonLoading(button, false);
      if (!res || !res.ok) {
        showToast(res && res.error ? res.error : 'Austragen fehlgeschlagen', 'error');
        return;
      }
      showToast('Du wurdest ausgetragen');
      showSpinner(true);
      await refreshBootstrap(true);
      showSpinner(false);
      if (reopenDetails) {
        await openDetails(training, true);
      }
    }

    async function handleUnavailable(training, set, button = null, reopenDetails = false) {
      setButtonLoading(button, true);
      const api = set ? 'apiSetUnavailable' : 'apiUnsetUnavailable';
      const res = await apiAuthed(api, training.training_id);
      setButtonLoading(button, false);
      if (!res || !res.ok) {
        showToast(res && res.error ? res.error : 'Aktion fehlgeschlagen', 'error');
        return;
      }
      showToast(set ? 'Als nicht verfügbar markiert' : 'Verfügbarkeit wieder hergestellt');
      showSpinner(true);
      await refreshBootstrap(true);
      showSpinner(false);
      if (reopenDetails) {
        await openDetails(training, true);
      }
    }

    async function openDetails(training, reopen = false, existingDetails = null) {
      const current = state.upcoming.find((t) => String(t.training_id) === String(training.training_id));
      const trainingData = current || training;
      if (!reopen) {
        UIComponents.createModal({
          title: `${trainingData.gruppe} · ${trainingData.datum}`,
          body: '<p class="muted">Lade Details...</p>',
          actions: [],
        });
      }

      const modal = document.querySelector('[data-modal-backdrop]');
      if (!modal) return;
      const footer = modal.querySelector('.modal-footer');
      if (footer) footer.innerHTML = '';

      const details = existingDetails || (await apiAuthed('apiTrainingDetails', trainingData.training_id));
      if (!details || !details.ok) {
        console.error(details);
        const errorText = details?.error || 'Details konnten nicht geladen werden.';
        UIComponents.setModalBody(`<div class="error-box">${errorText}</div>`);
        return;
      }

      const isUnavailable = details.unavailable.some((u) => String(u.trainer_id) === String(sessionUser?.trainer_id));
      const ownEntry = findOwnEinteilung(trainingData.training_id);
      const trainingStatus = details.training?.status || trainingData.status;
      const isPlanned = String(trainingStatus) === 'geplant';

      const body = `
        <div class="section">
          <div class="section-title">${trainingData.datum} · ${trainingData.start}&ndash;${trainingData.ende}</div>
          <p class="muted">${trainingData.ort}</p>
          <p class="muted">Eingeteilt ${trainingData.eingeteilt} / benötigt ${trainingData.benoetigt_trainer} · ${trainingData.offen_text}</p>
        </div>
        ${renderTrainerList('Eingetragene Trainer', details.signups || [], 'Noch niemand eingetragen')}
        ${renderUnavailable(details.unavailable || [])}
        ${renderPlan(details.plan)}
      `;

      UIComponents.setModalBody(body);

      const actions = [];
      if (isUnavailable) {
        actions.push({
          id: 'btnUnavailable',
          label: 'Verfügbar',
          onClick: (btn) => handleUnavailable(trainingData, false, btn, true),
          variant: 'primary',
        });
      } else if (ownEntry) {
        actions.push({
          id: 'btnWithdraw',
          label: 'Austragen',
          onClick: (btn) => handleWithdraw(trainingData, { button: btn, entryId: ownEntry.einteilung_id, reopenDetails: true }),
          variant: 'ghost',
        });
      } else {
        actions.push({
          id: 'btnEnroll',
          label: 'Eintragen',
          onClick: (btn) => handleEnroll(trainingData, { button: btn, reopenDetails: true }),
          variant: 'primary',
        });
      }

      if (!isUnavailable) {
        actions.push({
          id: 'btnUnavailable',
          label: 'Nicht verfügbar',
          onClick: (btn) => handleUnavailable(trainingData, true, btn, true),
          variant: 'danger',
        });
      }

      actions.forEach((action) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.id = action.id;
        btn.textContent = action.label;
        btn.className = `btn ${action.variant || 'ghost'}`;
        btn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          ev.preventDefault();
          action.onClick?.(btn);
        });
        if (!isPlanned) btn.disabled = true;
        footer?.appendChild(btn);
      });

    }

    function init() {
      initElements();
      try {
        showPast = localStorage.getItem(STORAGE_SHOW_PAST) === '1';
      } catch (e) {
        showPast = false;
      }
      if (els.togglePast) {
        els.togglePast.checked = showPast;
      }
      registerFilterEvents();
    }

    return {
      init,
      setData,
    };
  })();
</script>
